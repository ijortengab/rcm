#!/bin/bash

# Rapid Construct Massive
#
# (c) IjorTengab <ijortengab@systemix.id>
#
# https://github.com/ijortengab/rcm
#
# Command to download: `wget git.io/rcm`
#

# Parse arguments. Generated by parse-options.sh
_new_arguments=()
_n=
while [[ $# -gt 0 ]]; do
    case "$1" in
        --help|-h) help=1; shift ;;
        --version|-V) version=1; shift ;;
        --interactive) interactive=1; shift ;;
        --non-interactive|-x) interactive=0; shift ;;
        --resolved|-r) resolve_dependencies=0; shift ;;
        --slow|-s) slow=1; shift ;;
        --verbose|-v) verbose="$((verbose+1))"; shift ;;
        --with-resolve-dependencies) resolve_dependencies=1; shift ;;
        --without-resolve-dependencies) resolve_dependencies=0; shift ;;
        --)
            while [[ $# -gt 0 ]]; do
                case "$1" in
                    *) _new_arguments+=("$1"); shift ;;
                esac
            done
            ;;
        --[^-]*) shift ;;
        install|update|get|history|list)
            while [[ $# -gt 0 ]]; do
                case "$1" in
                    *) _new_arguments+=("$1"); shift ;;
                esac
            done
            ;;
        *) _new_arguments+=("$1"); shift ;;
    esac
done
set -- "${_new_arguments[@]}"
_new_arguments=()
while [[ $# -gt 0 ]]; do
    case "$1" in
        -[^-]*) OPTIND=1
            while getopts ":hVxrsv" opt; do
                case $opt in
                    h) help=1 ;;
                    V) version=1 ;;
                    x) interactive=0 ;;
                    r) resolve_dependencies=0 ;;
                    s) slow=1 ;;
                    v) verbose="$((verbose+1))" ;;
                esac
            done
            _n="$((OPTIND-1))"
            _n=${!_n}
            shift "$((OPTIND-1))"
            if [[ "$_n" == '--' ]];then
                while [[ $# -gt 0 ]]; do
                    case "$1" in
                        *) _new_arguments+=("$1"); shift ;;
                    esac
                done
            fi
            ;;
        --) shift
            while [[ $# -gt 0 ]]; do
                case "$1" in
                    *) _new_arguments+=("$1"); shift ;;
                esac
            done
            ;;
        install|update|get|history|list)
            while [[ $# -gt 0 ]]; do
                case "$1" in
                    *) _new_arguments+=("$1"); shift ;;
                esac
            done
            ;;
        *) _new_arguments+=("$1"); shift ;;
    esac
done
set -- "${_new_arguments[@]}"
unset _new_arguments
unset _n

# Command.
operand=
if [ -n "$1" ];then
    case "$1" in
        update|history|install|get|list) command="$1"; shift ;;
        *) operand="$1"; shift ;;
    esac
else
    command=usage
fi

if [ -n "$operand" ];then
    if [[ "$operand" =~ : ]];then
        command_raw=`cut -d: -f1 <<< "${operand}"`
        command_version=`cut -d: -f2 <<< "${operand}"`
    else
        command_raw="$operand"
    fi
    [ -n "$command_version" ] && command_version=":${command_version}"
    command="rcm-${command_raw}";
fi

# Parse arguments per command. Generated by parse-options.sh
case "$command" in
    install)
        _new_arguments=()
        while [[ $# -gt 0 ]]; do
            case "$1" in
                --path=*) path="${1#*=}"; shift ;;
                --path) if [[ ! $2 == "" && ! $2 =~ (^--$|^-[^-]|^--[^-]) ]]; then path="$2"; shift; fi; shift ;;
                --source=*) source="${1#*=}"; shift ;;
                --source) if [[ ! $2 == "" && ! $2 =~ (^--$|^-[^-]|^--[^-]) ]]; then source="$2"; shift; fi; shift ;;
                --url=*) url="${1#*=}"; shift ;;
                --url) if [[ ! $2 == "" && ! $2 =~ (^--$|^-[^-]|^--[^-]) ]]; then url="$2"; shift; fi; shift ;;
                --[^-]*) shift ;;
                *) _new_arguments+=("$1"); shift ;;
            esac
        done
        set -- "${_new_arguments[@]}"
        unset _new_arguments
        ;;
    update)
        _new_arguments=()
        while [[ $# -gt 0 ]]; do
            case "$1" in
                --path=*) path="${1#*=}"; shift ;;
                --path) if [[ ! $2 == "" && ! $2 =~ (^--$|^-[^-]|^--[^-]) ]]; then path="$2"; shift; fi; shift ;;
                --rollback) rollback=1; shift ;;
                --url=*) url="${1#*=}"; shift ;;
                --url) if [[ ! $2 == "" && ! $2 =~ (^--$|^-[^-]|^--[^-]) ]]; then url="$2"; shift; fi; shift ;;
                --[^-]*) shift ;;
                *) _new_arguments+=("$1"); shift ;;
            esac
        done
        set -- "${_new_arguments[@]}"
        unset _new_arguments
        ;;
    get)
        _new_arguments=()
        while [[ $# -gt 0 ]]; do
            case "$1" in
                --save-as=*) save_as="${1#*=}"; shift ;;
                --save-as) if [[ ! $2 == "" && ! $2 =~ (^--$|^-[^-]|^--[^-]) ]]; then save_as="$2"; shift; fi; shift ;;
                --[^-]*) shift ;;
                *) _new_arguments+=("$1"); shift ;;
            esac
        done
        set -- "${_new_arguments[@]}"
        unset _new_arguments
        ;;
    history)
        _new_arguments=()
        while [[ $# -gt 0 ]]; do
            case "$1" in
                --delete=*) delete+=("${1#*=}"); shift ;;
                --delete) if [[ ! $2 == "" && ! $2 =~ (^--$|^-[^-]|^--[^-]) ]]; then delete+=("$2"); shift; fi; shift ;;
                --delete-all) delete_all=1; shift ;;
                --fast) fast=1; shift ;;
                --) shift
                    while [[ $# -gt 0 ]]; do
                        case "$1" in
                            *) _new_arguments+=("$1"); shift ;;
                        esac
                    done
                    ;;
                --[^-]*) shift ;;
                *) _new_arguments+=("$1"); shift ;;
            esac
        done
        set -- "${_new_arguments[@]}"
        unset _new_arguments
        ;;
    list)
        _new_arguments=()
        while [[ $# -gt 0 ]]; do
            case "$1" in
                --raw) raw=1; shift ;;
                --[^-]*) shift ;;
                *) _new_arguments+=("$1"); shift ;;
            esac
        done
        set -- "${_new_arguments[@]}"
        unset _new_arguments
        ;;
esac

# Common Functions.
red() { echo -ne "\e[91m" >&2; echo -n "$@" >&2; echo -ne "\e[39m" >&2; }
green() { echo -ne "\e[92m" >&2; echo -n "$@" >&2; echo -ne "\e[39m" >&2; }
yellow() { echo -ne "\e[93m" >&2; echo -n "$@" >&2; echo -ne "\e[39m" >&2; }
blue() { echo -ne "\e[94m" >&2; echo -n "$@" >&2; echo -ne "\e[39m" >&2; }
magenta() { echo -ne "\e[95m" >&2; echo -n "$@" >&2; echo -ne "\e[39m" >&2; }
error() { echo -n "$INDENT" >&2; red '#' "$@" >&2; echo >&2; }
success() { echo -n "$INDENT" >&2; green '#' "$@" >&2; echo >&2; }
chapter() { echo -n "$INDENT" >&2; yellow '#' "$@" >&2; echo >&2; }
title() { echo -n "$INDENT" >&2; blue '#' "$@" >&2; echo >&2; }
code() { echo -n "$INDENT" >&2; magenta "$@" >&2; echo >&2; }
x() { echo >&2; exit 1; }
e() { echo -n "$INDENT" >&2; echo -n "$@" >&2; }
_() { echo -n "$INDENT" >&2; echo -n "#"' ' >&2; [ -n "$1" ] && echo -n "$@" >&2; }
_,() { echo -n "$@" >&2; }
_.() { echo >&2; }
__() { echo -n "$INDENT" >&2; echo -n "#" '    ' >&2; [ -n "$1" ] && echo "$@" >&2; }
____() { echo >&2; [ -n "$RCM_DELAY" ] && sleep "$RCM_DELAY"; }

# Define variables and constants.
BINARY_DIRECTORY=${BINARY_DIRECTORY:=[__DIR__]}
# If not set in argument, try load from environment.
[ -z "$verbose" ] && verbose="$RCM_VERBOSE"
[ -z "$interactive" ] && interactive="$RCM_INTERACTIVE"
[ -z "$resolve_dependencies" ] && resolve_dependencies="$RCM_RESOLVE_DEPENDENCIES"
# If set in environment, set to variable.
[ -n "$RCM_TABLE_DOWNLOADS" ] && table_downloads="$RCM_TABLE_DOWNLOADS"
[ -n "$RCM_FAST" ] && fast="$RCM_FAST"
[ -z "$fast" ] && fast=1
[ -n "$slow" ] && fast=
RCM_DELAY=${RCM_DELAY:=.5}; [ -n "$fast" ] && unset RCM_DELAY
loud=; debug=; quiet=
[[ -z "$verbose" || "$verbose" -lt 1 ]] && quiet=1 || quiet=
[[ "$verbose" -gt 0 ]] && loud=1
[[ "$verbose" -gt 1 ]] && loud=1 && louder=1
[[ "$verbose" -gt 2 ]] && loud=1 && louder=1 && debug=1

# Functions. Help and Version.
printVersion() {
    echo '0.16.16'
}
printHelp() {
    title Rapid Construct Massive
    _ 'Version '; yellow `printVersion`; _.
    _ 'URL '; yellow git.io/rcm; _.
    _.
cat << EOF
Usage: rcm
       rcm [command]
       rcm history --delete-all
       rcm history --delete rcm-wsl-setup-lemp-stack --delete rcm-composer-autoinstaller
       rcm install drupal --url https://github.com/ijortengab/drupal-autoinstaller --path rcm/rcm-drupal.sh
       rcm install ispconfig --url https://github.com/ijortengab/ispconfig-autoinstaller --path rcm/rcm-ispconfig.sh
       rcm install
       rcm install <commmand>
       rcm update
       rcm update <commmand>
       rcm get <script>
       rcm list

Available commands: history, update, install, get, list.

Options:

Global Options:
   --slow, -s
        Add delay every subtask.
   --version
        Print version of this script.
   --help
        Show this help.
   --binary-directory-exists-sure
        Bypass binary directory checking.
   --interactive
        Show asking for confirmation if needed. Default action.
   --non-interactive, -x
        Run without ever asking for user input.
   --verbose, -v
        Verbose mode. Causes rcm to print debugging messages about its progress.
        Multiple -v options increase the verbosity.
        The maximum is 3.
   --without-resolve-dependencies
        Skip resolve dependenices.
   --with-resolve-dependencies
        Resolve dependenices. Default action.
   --resolved, -r
        Alias of --without-resolve-dependencies.

Environment Variables:
   BINARY_DIRECTORY
        Default to $BINARY_DIRECTORY
EOF
}

# Help and Version.
[ -n "$help" ] && { printHelp; exit 1; }
[ -n "$version" ] && { printVersion; exit 1; }

# Functions before execute command.
resolve_relative_path() {
    if [ -d "$1" ];then
        cd "$1" || return 1
        pwd
    elif [ -e "$1" ];then
        if [ ! "${1%/*}" = "$1" ]; then
            cd "${1%/*}" || return 1
        fi
        echo "$(pwd)/${1##*/}"
    else
        return 1
    fi
}
fileMustExists() {
    # global used:
    # global modified:
    # function used: __, success, error, x
    if [ -f "$1" ];then
        __; green File '`'$(basename "$1")'`' ditemukan.; _.
    else
        __; red File '`'$(basename "$1")'`' tidak ditemukan.; x
    fi
}
userInputBooleanDefaultYes() {
    __;  _, '['; yellow Enter; _, ']'; _, ' '; yellow Y; _, 'es and continue.'; _.
    __;  _, '['; yellow Esc; _, ']'; _, ' '; yellow N; _, 'o and skip.'; _.
    boolean=
    while true; do
        __; read -rsn 1 -p "Select: " char
        if [ -z "$char" ];then
            char=y
        fi
        case $char in
            y|Y) echo "$char"; boolean=1; break;;
            n|N) echo "$char"; break ;;
            $'\33') echo "n"; break ;;
            *) echo
        esac
    done
}
userInputBooleanDefaultNo() {
    __;  _, '['; yellow Enter; _, ']'; _, ' '; yellow N; _, 'o and skip.'; _.
    __;  _, '['; yellow Y; _, ']'; _, ' '; yellow Y; _, 'es and continue.'; _.
    boolean=
    while true; do
        __; read -rsn 1 -p "Select: " char
        if [ -z "$char" ];then
            char=n
        fi
        case $char in
            y|Y) echo "$char"; boolean=1; break;;
            n|N) echo "$char"; break ;;
            *) echo
        esac
    done
}
printBackupDialog() {
    _; _.
    __; _, Restore the value:' '; yellow "${backup_value}"; _, '. '; _, Would you like to use that value?; _.
    userInputBooleanDefaultYes
    if [ -n "$boolean" ];then
        _; _.
        value="$backup_value";
        if [ -n "$is_flag" ];then
            __; green Argument; _, ' '; magenta "$parameter"; _, ' ';  green added with value' '; yellow $value; green ' 'which is restored.; _.
        else
            __; green Argument; _, ' '; magenta "$parameter"; _, ' ';  green filled with value' '; yellow $value; green ' 'which is restored.; _.
        fi
    fi
}
printBackupFlagDialog() {
    _; _.
    __; _, This argument has been added before. Would you like to restore this argument?; _.
    userInputBooleanDefaultYes
    if [ -n "$boolean" ];then
        _; _.
        __; green Argument; _, ' '; magenta "$parameter"; _, ' ';  green added which is restored.; _.
    fi
}
printHistoryDialog() {
    local count_max=$(wc -l <<< "$history_value")
    if [ $count_max -gt 9 ];then
        count_max=9
    fi
    unset count
    declare -i count
    count=0
    _; _.
    __ There are values available from history.
    while read opt; do
        count+=1
        __; _, '['; yellow $count; _, ']'; _, ' '; _, "$opt"; _.
    done <<< "$history_value"
    _; _.
    __;  _, '['; yellow Enter; _, ']'; _, ' '; yellow S; _, 'kip and continue.'; _.
    _; _.
    __ Press the yellow key to select.
    while true; do
        __; read -rsn 1 -p "Select: " char;
        if [ -z "$char" ];then
            char=s
        fi
        case $char in
            s|S) echo "$char"; break ;;
            [1-$count_max])
                echo "$char"
                value=$(sed -n ${char}p <<< "$history_value")
                _; _.
                __; green Argument; _, ' '; magenta "$parameter"; _, ' ';  green filled with value' '; yellow "$value"; green ' 'which is selected from the list of history.; _.
                save_history=
                break ;;
            *) echo
        esac
    done
}
printSelectDialog() {
    declare -i count
    declare -i new_line
    local source=("${!1}")
    local what="$2"
    local each reference_key
    if [ -z "$what" ];then
        what=value
        if [ "${#source[@]}" -gt 1 ];then
            what=values
        fi
    fi
    _; _.
    words_array=("${source[@]}")
    wordWrapList "Available ${what}:"
    _; _.
    __; _, '['; yellow Enter; _, ']'; _, ' '; yellow T; _, 'ype the value.'; _.
    __; _, '['; yellow Backspace; _, ']'; _, ' '; yellow S; _, 'witch to select list.'; _.
    if [ -z "$is_required" ];then
        __; _, '['; yellow Esc; _, ']'; _, ' '; yellow L; _, 'eave blank and skip.'; _.
    fi
    _; _.
    __ Press the yellow key to select.
    select_mode=
    local type_mode=
    local skip=
    while true; do
        __; read -rsn 1 -p "Select: " char;
        if [ -z "$char" ];then
            char=t
        fi
        if [ -n "$is_required" ];then
            case $char in
                t|T) type_mode=1; echo "$char"; break ;;
                s|S) select_mode=1; echo "$char"; break ;;
                $'\177') select_mode=1; echo "s"; break ;;
                *) echo; new_line+=1
            esac
        else
            case $char in
                t|T) type_mode=1; echo "$char"; break ;;
                s|S) select_mode=1; echo "$char"; break ;;
                $'\177') select_mode=1; echo "s"; break ;;
                $'\33') skip=1; echo "l"; break ;;
                l|L) skip=1; echo "$char"; break ;;
                *) echo; new_line+=1
            esac
        fi
    done
    # Credit: https://stackoverflow.com/questions/5861428/bash-script-erase-previous-line
    PREVIOUS_LINE=5
    if [ -z "$is_required" ];then
        PREVIOUS_LINE=$((PREVIOUS_LINE+1))
    fi
    if [[ -n "$select_mode" ]];then
        PREVIOUS_LINE=$((PREVIOUS_LINE+WRAP_LINE+1+new_line))
        for ((i = 0 ; i < $PREVIOUS_LINE ; i++)); do
            printf '\e[A\e[K'
        done
        __ Available values:
        for ((i = 0 ; i < ${#source[@]} ; i++)); do
            count+=1
            if [ $count -lt 10 ];then
                __; _, '['; yellow $count; _, ']'; _, ' '; _, "${source[$i]}"; _.
            else
                __; _, '['$count']' "${source[$i]}"; _.
            fi
        done
        _; _.
        __; _, '['; yellow Enter; _, ']'; _, ' '; _, 'Type the '; yellow N; _, 'umber key.'; _.
        if [ -z "$is_required" ];then
            __; _, '['; yellow Esc; _, ']'; _, ' '; yellow L; _, 'eave blank and skip.'; _.
        fi
        _; _.
        __ Press the yellow key to select.
        count_max="${#source[@]}"
        if [ $count_max -gt 9 ];then
            count_max=9
        fi
        while true; do
            __; read -rsn 1 -p "Select: " char;
            if [ -z "$char" ];then
                char=n
            fi
            case $char in
                n|N) echo "$char"; break ;;
                [1-$count_max])
                    echo "$char"
                    i=$((char - 1))
                    value="${source[$i]}"
                    break ;;
                *)
                    if [ -n "$is_required" ];then
                        echo
                    else
                        case $char in
                            $'\33') skip=1; echo "l"; break ;;
                            l|L) skip=1; echo "$char"; break ;;
                            *) echo
                        esac
                    fi
            esac
        done
        if [[ -z "$skip" ]];then
            until [ -n "$value" ];do
                _; _.
                __; read -p "Type the number: " value
                if [[ $value =~ [^0-9] ]];then
                    value=
                    __; red Please type one of available number.;_.
                fi
                if [[ $value =~ ^0 ]];then
                    value=
                    __; red Please type one of available number.;_.
                fi
                if [ -n "$value" ];then
                    value=$((value - 1))
                    value="${source[$value]}"
                    if [ -z "$value" ];then
                        __; red Please type one of available number.;_.
                    fi
                fi
            done
            _; _.
            __; green Argument; _, ' '; magenta "$parameter"; _, ' ';  green filled with value' '; yellow "$value"; green ' 'which is selected from the list.; _.
        fi
    fi
    if [[ -n "$type_mode" ]];then
        _; _.
    fi
    while true; do
        if [ -n "$value" ];then
            ArraySearch "$value" source[@]
            reference_key="$_return"; unset _return; # Clear.
            if [ -n "$reference_key" ];then
                break
            else
                __; red Please type one of available values.;_.
                value=
            fi
        else
            if [ -n "$is_required" ];then
                __; read -p "Type the value: " value
            elif [ -z "$skip" ];then
                __; read -p "Type the value or leave blank to skip: " value
                if [ -z "$value" ];then
                    break
                fi
            else
                break
            fi
        fi
    done
}
printSelectOtherDialog() {
    declare -i count
    declare -i new_line
    local source=("${!1}")
    local what="$2"
    local each reference_key
    if [ -z "$what" ];then
        what=value
        if [ "${#source[@]}" -gt 1 ];then
            what=values
        fi
    fi
    _; _.
    words_array=("${source[@]}")
    words_array+=(other)
    wordWrapList "Available ${what}:"
    _; _.
    __; _, '['; yellow Enter; _, ']'; _, ' '; yellow T; _, 'ype the value.'; _.
    __; _, '['; yellow Backspace; _, ']'; _, ' '; yellow S; _, 'witch to select list.'; _.
    if [ -z "$is_required" ];then
        __; _, '['; yellow Esc; _, ']'; _, ' '; yellow L; _, 'eave blank and skip.'; _.
    fi
    _; _.
    __ Press the yellow key to select.
    local select_mode=
    local type_mode=
    local skip=
    while true; do
        __; read -rsn 1 -p "Select: " char;
        if [ -z "$char" ];then
            char=t
        fi
        case $char in
            t|T) type_mode=1; echo "$char"; break ;;
            s|S) select_mode=1; echo "$char"; break ;;
            $'\177') select_mode=1; echo "s"; break ;;
            *)
                if [ -n "$is_required" ];then
                    echo; new_line+=1
                else
                    case $char in
                        $'\33') skip=1; echo "l"; break ;;
                        l|L) skip=1; echo "$char"; break ;;
                        *) echo; new_line+=1
                    esac
                fi
        esac
    done
    # Credit: https://stackoverflow.com/questions/5861428/bash-script-erase-previous-line
    PREVIOUS_LINE=5
    if [ -z "$is_required" ];then
        PREVIOUS_LINE=$((PREVIOUS_LINE+1))
    fi
    if [[ -n "$select_mode" ]];then
        PREVIOUS_LINE=$((PREVIOUS_LINE+WRAP_LINE+1+new_line))
        for ((i = 0 ; i < $PREVIOUS_LINE ; i++)); do
            printf '\e[A\e[K'
        done
        __ Available values:
        for ((i = 0 ; i < ${#source[@]} ; i++)); do
            count+=1
            if [ $count -lt 10 ];then
                __; _, '['; yellow $count; _, ']'; _, ' '; _, "${source[$i]}"; _.
            else
                __; _, '['$count']' "${source[$i]}"; _.
            fi
        done
        _; _.
        __; _, '['; yellow Enter; _, ']'; _, ' '; _, 'Type the '; yellow N; _, 'umber key.'; _.
        __; _, '['; yellow Backspace; _, ']'; _, ' '; _, 'Switch to '; yellow T; _, 'ype other value.'; _.
        if [ -z "$is_required" ];then
            __; _, '['; yellow Esc; _, ']'; _, ' '; yellow L; _, 'eave blank and skip.'; _.
        fi
        _; _.
        __ Press the yellow key to select.
        count_max="${#source[@]}"
        if [ $count_max -gt 9 ];then
            count_max=9
        fi
        while true; do
            __; read -rsn 1 -p "Select: " char;
            if [ -z "$char" ];then
                char=n
            fi
            case $char in
                t|T) type_mode=1; echo "$char"; break ;;
                $'\177') type_mode=1; echo "s"; break ;;
                n|N) echo "$char"; break ;;
                [1-$count_max])
                    echo "$char"
                    i=$((char - 1))
                    value="${source[$i]}"
                    break ;;
                *)
                    if [ -n "$is_required" ];then
                        echo
                    else
                        case $char in
                            $'\33') skip=1; echo "l"; break ;;
                            l|L) skip=1; echo "$char"; break ;;
                            *) echo
                        esac
                    fi
            esac
        done
        if [[ -z "$type_mode" && -z "$skip" ]];then
            until [ -n "$value" ];do
                _; _.
                __; read -p "Type the number: " value
                if [[ $value =~ [^0-9] ]];then
                    value=
                    __; red Please type one of available number.;_.
                fi
                if [[ $value =~ ^0 ]];then
                    value=
                    __; red Please type one of available number.;_.
                fi
                if [ -n "$value" ];then
                    value=$((value - 1))
                    value="${source[$value]}"
                    if [ -z "$value" ];then
                        __; red Please type one of available number.;_.
                    fi
                fi
            done
            _; _.
            __; green Argument; _, ' '; magenta "$parameter"; _, ' ';  green filled with value' '; yellow "$value"; green ' 'which is selected from the list.; _.
        fi
    fi
    if [[ -n "$type_mode" ]];then
        _; _.
        if [ -z "$value" ];then
            if [ -n "$is_required" ];then
                __; read -p "Type the value: " value
            elif [ -z "$skip" ];then
                __; read -p "Type the value or leave blank to skip: " value
            fi
            is_typing=1
        fi
    fi
}
Rcm_github_release() {
    local tag_name latest_version current_version current_path
    local backup_path url tempdir
    local mode=$1; shift
    local shell_script=$1; shift
    if [ -z "$shell_script" ];then
        error "Operand <shell_script> required."; x
    fi
    local github_repo=$1; shift
    if [ -z "$github_repo" ];then
        error "Operand <github_repo> required."; x
    fi
    local blob_path=$1; shift
    if [ -z "$blob_path" ];then
        error "Operand <blob_path> required."; x
    fi
    case $mode in
        install)
            if command -v $shell_script >/dev/null;then
                error "Command has exists: ${shell_script}."; x
            fi
            tag_name=$(Rcm_wget 3600 https://api.github.com/repos/$github_repo/releases/latest | grep '^  "tag_name": ".*",$' | sed -E 's/  "tag_name": "(.*)",/\1/')
            if [ -z "$tag_name" ];then
                error "The repository does not have any releases."; x
            fi
            latest_version=$(sed -E 's/v?(.*)/\1/' <<< "$tag_name")
        ;;
        update)
            if ! command -v $shell_script >/dev/null;then
                error "Command not found: ${shell_script}."; x
            fi
            current_version=`$shell_script --version`
            current_path=$(which $shell_script)
            current_path=$(realpath "$current_path")
            if [ -n "$rollback" ];then
                previous_path=$HOME/.cache/rcm/$github_repo/rollback/$shell_script
                if [ -f "$previous_path" ];then
                    # Override now
                    cp "$previous_path" "$current_path"
                    old_version=$current_version
                    current_version=`$shell_script --version`
                    _ 'Success rollback '; magenta $shell_script; _, ' to version: '; yellow $current_version; _.
                    rm $HOME/.cache/rcm/$github_repo/rollback/$shell_script
                    # Dalam satu direktori ini bisa terdapat banyak file. Contoh
                    # rcm, rcm-composer-autoinstaller
                    rmdir --ignore-fail-on-non-empty $HOME/.cache/rcm/$github_repo/rollback
                else
                    _ 'No previous version found. '; _.
                fi
                exit 0
            fi
            tag_name=$(Rcm_wget 60 https://api.github.com/repos/$github_repo/releases/latest | grep '^  "tag_name": ".*",$' | sed -E 's/  "tag_name": "(.*)",/\1/')
            if [ -z "$tag_name" ];then
                error "The repository does not have any releases."; x
            fi
            latest_version=$(sed -E 's/v?(.*)/\1/' <<< "$tag_name")
            if [ "$current_version" == "$latest_version" ];then
                if [ -n "$loud" ];then
                    _ 'You are already using the latest available '; magenta $shell_script; _, ' version: '; yellow $latest_version; _.
                fi
                exit 0
            fi
            backup_path=$HOME/.cache/rcm/$github_repo/rollback/$shell_script
            mkdir -p $(dirname "$backup_path")
            cp "$current_path" "$backup_path"
            if [ ! -f "$backup_path" ];then
                error Failed to save backup file: "$backup_path".; x
            fi
    esac
    local cache_directory=$HOME/.cache/rcm/$github_repo/$latest_version
    if [ ! -d "$cache_directory" ];then
        if [ -n "$loud" ];then
            _ 'Downloading version: '; yellow $latest_version; _.
        fi
        url='https://api.github.com/repos/'$github_repo'/tarball/'$tag_name
        tempdir=$(mktemp -d)
        cd "$tempdir"
        wget -q -O "${tag_name}.tar.gz" "$url"
        if [ ! -f "${tag_name}.tar.gz" ];then
            error Failed to download file: "${tag_name}.tar.gz".
            rm -rf "$tempdir"
            x
        fi
        tar xfz "${tag_name}.tar.gz"
        local found_directory_extracted=$(find -maxdepth 1 -mindepth 1 -type d)
        if [ ! -d "$found_directory_extracted" ];then
            error Failed to extract archieve: "${tag_name}.tar.gz".;
            cd - >/dev/null
            rm -rf "$tempdir"
            x
        fi
        mkdir -p $(dirname "$cache_directory");
        mv $(realpath "$found_directory_extracted") "$cache_directory"
        # Cleaning.
        cd - >/dev/null
        rm -rf "$tempdir"
    else
        if [ -n "$loud" ];then
            _ 'Using downloaded version: '; yellow $latest_version; _.
        fi
    fi
    local filename="${cache_directory}/${blob_path}"
    if [ ! -f "$filename" ];then
        if [ -n "$display_waiting" ];then
            printf "\r\033[K"
        fi
        error File is not found: "$filename".;
        [ -n "$quiet" ] && kill -SIGTERM $$
        x
    fi
    case $mode in
        install)
            if [ -f "${BINARY_DIRECTORY}/${shell_script}" ];then
                if [ -n "$debug" ];then
                    __ Backup file "${BINARY_DIRECTORY}/${shell_script}".
                fi
                backupFile move "${BINARY_DIRECTORY}/${shell_script}"
            elif [ -h "${BINARY_DIRECTORY}/${shell_script}" ];then
                if [ -n "$debug" ];then
                    __ Backup file "${BINARY_DIRECTORY}/${shell_script}".
                fi
                backupFile move "${BINARY_DIRECTORY}/${shell_script}"
            fi
            if [ -n "$loud" ];then
                code cp '"'$filename'"' '"'$BINARY_DIRECTORY/$shell_script'"'
            fi
            cp "$filename" $BINARY_DIRECTORY/$shell_script
            current_version=`$shell_script --version`
            if [ -n "$loud" ];then
                _ 'Success install '; magenta $shell_script; _, ' version: '; yellow $current_version; _.
            fi
        ;;
        update)
            cp "$filename" "$current_path"
            old_version=$current_version
            current_version=`$shell_script --version`
            if [ -n "$loud" ];then
                _ 'Success update '; magenta $shell_script; _, ' to version: '; yellow $current_version; _.
                _ To rollback version $old_version, execute the latest command with --rollback options.; _.
            fi
        ;;
    esac
}
sleepExtended() {
    # Menggunakan global variable countdown agar sleep ini dapat di-interupsi.
    # Contoh:
    # ```
    # immediately() {
    #     countdown=0
    # }
    # trap immediately SIGINT
    # sleepExtended 30
    # trap x SIGINT
    # ```
    local timer=$1
    local width=$2
    if [ -z "$width" ];then
        width=80
    fi
    if [ "$timer" -gt 0 ];then
        dikali10=$((timer*10))
        countdown=$dikali10
        _dotLength=$(( ( width * countdown ) / dikali10 ))
        printf "\r\033[K" >&2
        e; printf %"$_dotLength"s | tr " " "." >&2
        printf "\r"
        while [ "$countdown" -ge 0 ]; do
            dotLength=$(( ( width * countdown ) / dikali10 ))
            if [[ ! "$dotLength" == "$_dotLength" ]];then
                _dotLength="$dotLength"
                printf "\r\033[K" >&2
                e; printf %"$dotLength"s | tr " " "." >&2
                printf "\r"
            fi
            countdown=$((countdown - 1))
            sleep .1
        done
    fi
}
immediately() {
    countdown=0
}
backupFile() {
    local mode="$1"
    local oldpath="$2" i newpath
    local target_dir="$3"
    i=1
    dirname=$(dirname "$oldpath")
    basename=$(basename "$oldpath")
    if [ -n "$target_dir" ];then
        case "$target_dir" in
            parent) dirname=$(dirname "$dirname") ;;
            *) dirname="$target_dir"
        esac
    fi
    [ -d "$target_dir" ] || { echo 'Directory is not exists.' >&2; return 1; }
    newpath="${dirname}/${basename}.${i}"
    if [ -f "$newpath" ]; then
        let i++
        newpath="${dirname}/${basename}.${i}"
        while [ -f "$newpath" ] ; do
            let i++
            newpath="${dirname}/${basename}.${i}"
        done
    fi
    case $mode in
        move)
            mv "$oldpath" "$newpath" ;;
        copy)
            local user=$(stat -c "%U" "$oldpath")
            local group=$(stat -c "%G" "$oldpath")
            cp "$oldpath" "$newpath"
            chown ${user}:${group} "$newpath"
    esac
}
Rcm_wget() {
    # Global, untuk debug.
    local http_request line cache_file_basename
    local start end runtime line_number
    http_request=
    local expired="$1"
    local url="$2"
    local table=$HOME/.cache/rcm/rcm.table.cache
    local cache_file=
    if [ -f "$table" ];then
        line=$(grep -n -F "$url"' ' "$table")
        if [ -z "$line" ];then
            http_request=1
        else
            cache_file_basename=$(cut -d' ' -f2 <<< "$line")
            cache_file=$HOME/.cache/rcm/"$cache_file_basename"
        fi
    else
        http_request=1
    fi
    local do_delete_record_cache_file=
    if [ -n "$cache_file" ];then
        if [ -f "$cache_file" ];then
            start=`date -r "$cache_file" +'%s'`
            end=`date +%s`
            runtime=$((end-start))
            if [ $runtime -gt $expired ];then
                do_delete_record_cache_file=1
            fi
        else
            do_delete_record_cache_file=1
        fi
    fi
    if [ -n "$do_delete_record_cache_file" ];then
        line_number=$(cut -d':' -f1 <<< "$line")
        sed -i $line_number'd' "$table"
        http_request=1
        if [ -f "$cache_file" ];then
            rm "$cache_file"
        fi
        cache_file=
    fi
    if [ -n "$http_request" ];then
        mkdir -p $HOME/.cache/rcm
        cache_file=$(mktemp --tmpdir=$HOME/.cache/rcm rcm.wget.XXXXXXXXXXXX.cache)
        cache_file_basename=$(basename "$cache_file")
        # echo wget -q -O "$cache_file" "$url"
        wget -q -O "$cache_file" "$url"
        touch "$cache_file" # wajib karena wget mengubah modified sesuai http header response.
        mkdir -p $(dirname "$table")
        echo "$url" "$cache_file_basename" >> "$table"
    fi
    if [ ! -f "$cache_file" ];then
        exit 1
    fi
    cat "$cache_file"
}
Rcm_list() {
    if [ -f $HOME/.config/rcm/rcm.table.extension ] ;then
        cat $HOME/.config/rcm/rcm.table.extension | cut -d' ' -f1
    fi
    Rcm_list_internal
}
Rcm_list_internal() {
    # git ls-files | grep -E '^.+/rcm.+\.sh$' | cut -d/ -f2 | sed -e 's,^rcm-,,' -e 's,\.sh$,,'
    cat << 'RCM_LIST_INTERNAL'
certbot-apt
certbot-deploy-installer-nginx-authenticator-digitalocean
certbot-deploy-nginx
certbot-digitalocean-autoinstaller
certbot-obtain-authenticator-digitalocean
certbot-obtain-authenticator-nginx
composer-autoinstaller
cron-setup-wsl-autorun-crond
cron-setup-wsl-autorun-sshd
cron-setup-wsl-port-forwarding
debian-11-setup-basic
debian-12-setup-basic
dig-apt
dig-has-address
dig-is-name-exists
dig-is-record-exists
dig-watch-domain-exists
digitalocean-api-manage-domain-record
digitalocean-api-manage-domain
dovecot-multiple-certificate
mariadb-apt
mariadb-assign-grant-all
mariadb-database-autocreate
mariadb-setup-project-database
mariadb-user-autocreate
nginx-apt
nginx-reload
nginx-setup-front-controller-php
nginx-setup-hello-world-php
nginx-setup-hello-world-static
nginx-setup-php
nginx-setup-static
nginx-virtual-host-autocreate-php-multiple-root
nginx-virtual-host-autocreate-php
php-apt
php-fpm-setup-project-config
php-setup-adjust-cli-version
phpmyadmin-autoinstaller-nginx
postfix-apt
postfix-multiple-certificate
roundcube-autoinstaller-nginx
ssh-setup-open-ssh-tunnel
ssh-setup-sshd-listen-port
system-ram-swap-4gb
ubuntu-22.04-setup-basic
ubuntu-24.04-setup-basic
wsl-setup-lemp-stack
RCM_LIST_INTERNAL
}
Rcm_is_internal() {
    local command="$1"
    if [[ "$command" =~ ^rcm- ]];then
        command_list=$(Rcm_list_internal)
        command_without_prefix=$(sed s,^rcm-,, <<< "$command")
        if grep -q ^"$command_without_prefix"$ <<< "$command_list";then
            return 0
        fi
    fi
    return 1
}
Rcm_parse_url() {
    PHP_URL_SCHEME="$(echo "$1" | grep :// | sed -e's,^\(.*://\).*,\1,g')"
    _PHP_URL_SCHEME_REVERSE="$(echo ${1/$PHP_URL_SCHEME/})"
    _PHP_URL_USER_PASS="$(echo $_PHP_URL_SCHEME_REVERSE | grep @ | cut -d@ -f1)"
    # extract the user and password (if any)
    PHP_URL_PASS=`echo $_PHP_URL_USER_PASS | grep : | cut -d: -f2`
    if [ -n "$PHP_URL_PASS" ]; then
        PHP_URL_USER=`echo $_PHP_URL_USER_PASS | grep : | cut -d: -f1`
    else
        PHP_URL_USER=$_PHP_URL_USER_PASS
    fi
    _PHP_URL_HOST_PORT="$(echo ${_PHP_URL_SCHEME_REVERSE/$_PHP_URL_USER_PASS@/} | cut -d/ -f1)"
    # by request host without port
    PHP_URL_HOST="$(echo $_PHP_URL_HOST_PORT | sed -e 's,:.*,,g')"
    # by request - try to extract the port
    PHP_URL_PORT="$(echo $_PHP_URL_HOST_PORT | sed -e 's,^.*:,:,g' -e 's,.*:\([0-9]*\).*,\1,g' -e 's,[^0-9],,g')"
    # extract the path (if any)
    PHP_URL_PATH="$(echo $_PHP_URL_SCHEME_REVERSE | grep / | cut -d/ -f2-)"
}
Rcm_update() {
    if [ -z "$1" ];then
        error "Operand <extension> required."; x
    fi
    local extension=$1; shift
    local shell_script="rcm-${extension}"
    if ! command -v $shell_script >/dev/null;then
        error "Command not found: ${shell_script}."; x
    fi
    local table=$HOME/.config/rcm/rcm.table.extension
    if [ -z "$url" ];then
        line=
        if [ -f "$table" ];then
            line=$(grep -n "^$extension"' ' "$table" | tail -1)
        fi
        if [ -n "$line" ];then
            url=$(cut -d' ' -f2 <<< "$line")
            if [ -z "$path" ];then
                path=$(cut -d' ' -f3 <<< "$line")
            fi
        else
            if Rcm_is_internal "$shell_script";then
                url=https://github.com/ijortengab/rcm
                path=$(cut -d- -f2 <<< "$shell_script")/"$shell_script".sh
            fi
        fi
    fi
    notfound=
    if [ -z "$url" ];then
        notfound=1
        parameter='--url'
        description='The URL repository.'
        _ 'Argument '; magenta ${parameter};_, ' is '; yellow required;_, '.'; _.
        _ "${description}"; _.
    fi
    until [ -n "$url" ];do
        __; read -p "Type the value: " url
    done
    if [ -z "$path" ];then
        notfound=1
        parameter='--path'
        description='Path to the file. Default value is `'rcm/rcm-${extension}.sh'`.'
        _ 'Argument '; magenta ${parameter};_, ' is '; _, optional;_, '.'; _.
        _ "${description}"; _.
        __; read -p "Type the value or leave blank to skip: " path
    fi
    if [ -z "$path" ];then
        path=rcm/rcm-${extension}.sh
    fi
    Rcm_parse_url "$url"
    if [[ "$PHP_URL_HOST" == github.com ]];then
        if [ -n "$notfound" ];then
            mkdir -p $HOME/.config/rcm
            echo "$extension" "$url" "$path" >> "$table"
        fi
        github_owner_repo=$(cut -d/ -f 1,2 <<< $PHP_URL_PATH)
        Rcm_github_release update rcm-${extension} $github_owner_repo $path
    else
        error Only supports URLs from Github.;
        line=$(grep -n "^$extension"' ' "$table" | tail -1)
        if [ -n "$line" ];then
            line_number=$(cut -d':' -f1 <<< "$line")
            sed -i $line_number'd' "$table"
        fi
    fi
}
Rcm_install() {
    if [ -z "$1" ];then
        error "Operand <extension> required."; x
    fi
    local extension=$1; shift
    local shell_script="rcm-${extension}"
    if command -v $shell_script >/dev/null;then
        error "Command has exists: ${shell_script}."; x
    fi
    # VarDump extension url
    notfound=
    if [ -n "$source" ];then
        local table=$HOME/.config/rcm/rcm.table.extension
        line=
        if [ -f "$table" ];then
            line=$(grep -n "^$source"' ' "$table" | tail -1)
        fi
        if [ -n "$line" ];then
            url=$(cut -d' ' -f2 <<< "$line")
            path=-
        fi
    fi
    if [ -z "$url" ];then
        notfound=1
        parameter='--url'
        description='The URL repository.'
        _ 'Argument '; magenta ${parameter};_, ' is '; yellow required;_, '.'; _.
        _ "${description}"; _.
    fi
    until [ -n "$url" ];do
        __; read -p "Type the value: " url
    done
    if [ -n "$notfound" ];then
        ____
    fi
    if [[ "$path" == - ]];then
        path=rcm/rcm-${extension}.sh
    fi
    if [ -z "$path" ];then
        notfound=1
        parameter='--path'
        description='Path to the file. Default value is `'rcm/rcm-${extension}.sh'`.'
        _ 'Argument '; magenta ${parameter};_, ' is '; _, optional;_, '.'; _.
        _ "${description}"; _.
        __; read -p "Type the value or leave blank to skip: " path
    fi
    if [ -n "$notfound" ];then
        ____
    fi
    if [ -z "$path" ];then
        path=rcm/rcm-${extension}.sh
    fi
    Rcm_parse_url "$url"
    if [[ "$PHP_URL_HOST" == github.com ]];then
        github_owner_repo=$(cut -d/ -f 1,2 <<< $PHP_URL_PATH)
        Rcm_github_release install rcm-${extension} $github_owner_repo $path
        # Jika berhasil, maka simpan url.
        local table=$HOME/.config/rcm/rcm.table.extension
        mkdir -p $HOME/.config/rcm
        echo "$extension" "$url" "$path" >> "$table"
    else
        error Only supports URLs from Github.; x
    fi
    if ! command -v "$shell_script" > /dev/null;then
        error Command '`'$shell_script'`' not found, unable to auto download.; x
    fi
}
Rcm_get() {
    local url="$1"
    _ Memulai download.; _.
    if [ -n "$save_as" ];then
        local filename="$save_as"
    else
        Rcm_parse_url "$url"
        filename=$(basename "$PHP_URL_PATH")
    fi
    code wget '"'"$url"'"' -O '"'"$BINARY_DIRECTORY/$filename"'"'
    wget -q "$url" -O "$BINARY_DIRECTORY/$filename"
    fileMustExists "$BINARY_DIRECTORY/$filename"
    if [ ! -s "$BINARY_DIRECTORY/$filename" ];then
        __; magenta rm "$BINARY_DIRECTORY/$filename"; _.
        rm "$BINARY_DIRECTORY/$filename"
        __; red HTTP Response: 404 Not Found; x
    fi
    code chmod a+x "$BINARY_DIRECTORY/$filename"
    chmod a+x "$BINARY_DIRECTORY/$filename"
}
command-install() {
    loud=1;debug=1
    if [ $# -eq 0 ];then
        # Install diri sendiri.
        set -- update rcm ijortengab/rcm rcm.sh
        Rcm_github_release "${@}"
    else
        Rcm_install "${@}"
    fi
}
command-update() {
    loud=1;debug=1
    if [ $# -eq 0 ];then
        # Install diri sendiri.
        set -- update rcm ijortengab/rcm rcm.sh
        Rcm_github_release "${@}"
    else
        Rcm_update "${@}"
    fi
}
command-get() {
    Rcm_get "$@"
}
command-history() {
    directory=$HOME/.cache/rcm
    if [ ! -d "$directory" ];then
        exit 0
    fi
    cd "$directory"
    if [ -n "$delete_all" ];then
        rm *.bak 2>/dev/null
        rm *.history 2>/dev/null
        _ All history deleted.; _.
    elif [ "${#delete[@]}" -gt 0 ];then
        for each in "${delete[@]}";do
            if [ -f rcm."$each".history ];then
                rm rcm."$each".history
            fi
            if [ -f rcm."$each".bak ];then
                rm rcm."$each".bak
            fi
            _ History "$each" deleted.; _.
        done
    else
        ls *.history 2>/dev/null | sed -E 's,^rcm\.(.*)\.history$,\1,' | while read line; do
            yellow $line; _.
            if [ -f $line ];then
                contents="$(cat $line)"
                code "$contents"
                ____
            elif [ -f rcm.$line.history ];then
                contents="$(cat rcm.${line}.history)"
                code "$contents"
                ____
            fi
        done
    fi
}
command-list() {
    # git ls-files | grep -E '^.+/rcm.+\.sh$' | cut -d/ -f2 | sed -e s,^rcm-,, -e s,\.sh$,,
    if [ -n "$raw" ];then
        Rcm_list
        exit 0
    fi
    history_storage=$HOME'/.cache/rcm/rcm.history'
    save_history=1
    history_value=
    if [ -f "$history_storage" ];then
        history_value=$(tail -9 "$history_storage")
        parameter='<command>'
        printHistoryDialog
    fi
    if [ -z "$value" ];then
        _; _.
        _ Listing the command then execute it.; _.
        _; _.
        sleepExtended 3 30
        declare -i count
        is_required=1
        parameter=command
        command_list=$(Rcm_list)
        read -ra source -d '' <<< "$command_list"
        for ((i = 0 ; i < ${#source[@]} ; i++)); do
            count+=1
            __; _, '['$count']' "${source[$i]}"; _.
        done
        _; _.
        until [ -n "$value" ];do
            __; read -p "Type the number: " value
            if [[ $value =~ [^0-9] ]];then
                value=
                __; red Please type one of available number.;_.
            fi
            if [[ $value =~ ^0 ]];then
                value=
                __; red Please type one of available number.;_.
            fi
            if [ -n "$value" ];then
                value=$((value - 1))
                value="${source[$value]}"
                if [ -z "$value" ];then
                    __; red Please type one of available number.;_.
                fi
            fi
        done
    fi
    command_raw="${value}"
    command="rcm-${value}"
    _; _.
    _ Command' '; magenta $command_raw; _, ' 'selected.; _.
    ____

    if [ -n "$value" ];then
        if [ -f "$history_storage" ];then
            if grep -q -- "^${command}$" "$history_storage";then
                save_history=
            fi
        fi
    fi
    if [ -n "$save_history" ];then
        mkdir -p $(dirname "$history_storage")
        echo "$value" >> "$history_storage"
    fi
}
command-usage() {
    title Rapid Construct Massive
    _ Version; yellow ' '`printVersion`; _.
    _ URL; yellow ' 'git.io/rcm; _.
    _ Try; blue ' 'rcm; magenta ' '--help; _, ' 'for more information.; _.
}

# Define variables and constants.
__FILE__=$(resolve_relative_path "$0")
__DIR__=$(dirname "$__FILE__")
find='[__DIR__]'
replace="$__DIR__"
BINARY_DIRECTORY="${BINARY_DIRECTORY/"$find"/"$replace"}"

# Execute command.
if [[ -n "$command" && $(type -t "command-${command}") == function ]];then
    if [ "$command" == list ];then
        command-${command} "$@"
    else
        command-${command} "$@"
        exit 0
    fi
fi

# Title.
title rcm
____

# Dependency.
while IFS= read -r line; do
    [[ -z "$line" ]] || command -v `cut -d: -f1 <<< "${line}"` >/dev/null || { error Unable to proceed, command not found: '`'`cut -d: -f1 <<< "${line}"`'`'.; x; }
done <<< `printHelp 2>/dev/null | sed -n '/^Dependency:/,$p' | sed -n '2,/^\s*$/p' | sed 's/^ *//g'`

# Functions.
ArraySearch() {
    local index match="$1"
    local source=("${!2}")
    for index in "${!source[@]}"; do
       if [[ "${source[$index]}" == "${match}" ]]; then
           _return=$index; return 0
       fi
    done
    return 1
}
ArrayDiff() {
    # Computes the difference of arrays.
    #
    # Globals:
    #   Modified: _return
    #
    # Arguments:
    #   1 = Parameter of the array to compare from.
    #   2 = Parameter of the array to compare against.
    #
    # Returns:
    #   None
    #
    # Example:
    #   ```
    #   my=("cherry" "manggo" "blackberry" "manggo" "blackberry")
    #   yours=("cherry" "blackberry")
    #   ArrayDiff my[@] yours[@]
    #   # Get result in variable `$_return`.
    #   # _return=("manggo" "manggo")
    #   ```
    local e
    local source=("${!1}")
    local reference=("${!2}")
    _return=()
    # inArray is alternative of ArraySearch.
    inArray () {
        local e match="$1"
        shift
        for e; do [[ "$e" == "$match" ]] && return 0; done
        return 1
    }
    if [[ "${#reference[@]}" -gt 0 ]];then
        for e in "${source[@]}";do
            if ! inArray "$e" "${reference[@]}";then
                _return+=("$e")
            fi
        done
    else
        _return=("${source[@]}")
    fi
}
ArrayUnique() {
    # Removes duplicate values from an array.
    #
    # Globals:
    #   Modified: _return
    #
    # Arguments:
    #   1 = Parameter of the input array.
    #
    # Returns:
    #   None
    #
    # Example:
    #   ```
    #   my=("cherry" "manggo" "blackberry" "manggo" "blackberry")
    #   ArrayUnique my[@]
    #   # Get result in variable `$_return`.
    #   # _return=("cherry" "manggo" "blackberry")
    #   ```
    local e source=("${!1}")
    # inArray is alternative of ArraySearch.
    inArray () {
        local e match="$1"
        shift
        for e; do [[ "$e" == "$match" ]] && return 0; done
        return 1
    }
    _return=()
    for e in "${source[@]}";do
        if ! inArray "$e" "${_return[@]}";then
            _return+=("$e")
        fi
    done
}
ArrayShift() {
    local index
    local source=("${!1}")
    _return=()
    for (( index=1; index < ${#source[@]} ; index++ )); do
        _return+=("${source[$index]}")
    done
}
vercomp() {
    # https://www.google.com/search?q=bash+compare+version
    # https://stackoverflow.com/a/4025065
    if [[ $1 == $2 ]]; then
        return 0
    fi
    local IFS=.
    local i ver1=($1) ver2=($2)
    # fill empty fields in ver1 with zeros
    for ((i=${#ver1[@]}; i<${#ver2[@]}; i++)); do
        ver1[i]=0
    done
    for ((i=0; i<${#ver1[@]}; i++)); do
        if [[ -z ${ver2[i]} ]];then
            # fill empty fields in ver2 with zeros
            ver2[i]=0
        fi
        if ((10#${ver1[i]} > 10#${ver2[i]})); then
            return 1
        fi
        if ((10#${ver1[i]} < 10#${ver2[i]})); then
            return 2
        fi
    done
    return 0
}
Rcm_resolve_dependencies() {
    local commands_required_raw _help
    local command_required command_required_version
    local url github_owner_repo github_file_path github_media_type
    local is_updated
    commands_required_raw=("$1")
    PATH="${BINARY_DIRECTORY}:${PATH}"
    commands_exists=()
    if [ -n "$quiet" ];then
        display_waiting=1
    fi
    until [[ ${#commands_required_raw[@]} -eq 0 ]];do
        _commands_required=()
        if [ -n "$loud" ];then
            chapter Requires command.
            _ Versi rcm saat ini: ${rcm_version}.; _.
        fi
        for command_required_raw in "${commands_required_raw[@]}"; do
            command_required="$command_required_raw"
            command_required_version=
            if grep -q -F : <<< "$command_required";then
                command_required_version=$(cut -d: -f2 <<< "$command_required")
                command_required=$(cut -d: -f1 <<< "$command_required")
            elif Rcm_is_internal "$command_required";then
                command_required_version=${rcm_version}
            fi
            if [ -n "$loud" ];then
                _ Requires command: "$command_required"
            fi
            if command -v "$command_required" > /dev/null;then
                if [ -n "$loud" ];then
                    _, ' [FOUND].';
                fi
                if [ -z "$command_required_version" ];then
                    if [ -n "$loud" ];then
                        _.
                    fi
                else
                    command_current_version=$("$command_required" --version)
                    if [[ "$command_current_version" =~ [^0-9\.]+ ]];then
                        command_current_version=0
                    fi
                    if [[ ! "$command_required_version" == "$command_current_version" ]];then
                        if [ -n "$loud" ];then
                            _, ' Version required: '$command_required_version'.'
                            _, ' Current version: '$command_current_version'.'
                        fi
                    fi
                    vercomp $command_current_version $command_required_version
                    if [[ $? -lt 2 ]];then
                        if [ -n "$loud" ];then
                            _.
                        fi
                    else
                        if [ -n "$loud" ];then
                            _.
                        fi
                        is_updated=
                        if Rcm_is_internal "$command_required";then
                            github_owner_repo=ijortengab/rcm
                            github_file_path=$(cut -d- -f2 <<< "$command_required")/"$command_required".sh
                            if [ -n "$loud" ];then
                                code rcm update $(sed s,^rcm-,, <<< "$command_required")
                            fi
                            OLDINDENT="$INDENT"; INDENT+=''
                            INDENT+='    '
                            blob_path=$(cut -d- -f2 <<< "$command_required")/"$command_required".sh
                            Rcm_github_release update $command_required $github_owner_repo $github_file_path
                            INDENT="$OLDINDENT"
                            is_updated=1
                        elif [[ "$command_required" == rcm ]];then
                            if [ -n "$loud" ];then
                                code rcm self-update
                            fi
                            OLDINDENT="$INDENT"; INDENT+=''
                            INDENT+='    '
                            set -- update rcm ijortengab/rcm rcm.sh
                            Rcm_github_release "$@"
                            INDENT="$OLDINDENT"
                            is_updated=1
                        else
                            url=$(grep -F '['$command_required']' <<< "$table_downloads" | tail -1 | sed -E 's/.*\((.*)\).*/\1/')
                            if [ -n "$url" ];then
                                Rcm_parse_url "$url"
                                if [[ "$PHP_URL_HOST" == github.com ]];then
                                    # https://github.com/ijortengab/rcm/blob/master/cron/rcm-cron-setup-wsl-port-forwarding.sh
                                    # https://github.com/ijortengab/rcm/raw/master/cron/rcm-cron-setup-wsl-port-forwarding.sh
                                    # https://github.com/ijortengab/rcm/raw/refs/heads/master/cron/rcm-cron-setup-wsl-port-forwarding.sh
                                    github_media_type=$(cut -d/ -f 3 <<< $PHP_URL_PATH)
                                    if [[ $github_media_type == raw ]];then
                                        github_owner_repo=$(cut -d/ -f 1,2 <<< $PHP_URL_PATH)
                                        github_file_path=$(cut -d/ -f 5- <<< $PHP_URL_PATH)
                                        if [ -n "$loud" ];then
                                            code rcm update $(sed s,^rcm-,, <<< "$command_required") --url='"'"${PHP_URL_SCHEME}${PHP_URL_HOST}/${github_owner_repo}"'"' --path='"'"$github_file_path"'"'
                                        fi
                                        OLDINDENT="$INDENT"; INDENT+=''
                                        INDENT+='    '
                                        Rcm_github_release update $command_required $github_owner_repo $github_file_path
                                        INDENT="$OLDINDENT"
                                        is_updated=1
                                    fi
                                fi
                            fi
                        fi
                        if [[ -z "$is_updated" ]];then
                            if [ -n "$display_waiting" ];then
                                printf "\r\033[K"
                            fi
                            error Gagal Update;
                            [ -n "$quiet" ] && kill -SIGTERM $$
                            x
                        fi
                    fi
                fi
            else
                if [ -n "$loud" ];then
                    _, ' [NOTFOUND].'; _.
                fi
                if [[ -f "$BINARY_DIRECTORY/$command_required" && ! -s "$BINARY_DIRECTORY/$command_required" ]];then
                    __ Empty file detected.
                    __; magenta rm "$BINARY_DIRECTORY/$command_required"; _.
                    rm "$BINARY_DIRECTORY/$command_required"
                fi
                if [ ! -f "$BINARY_DIRECTORY/$command_required" ];then
                    if Rcm_is_internal "$command_required";then
                        PHP_URL_SCHEME='https://'
                        PHP_URL_HOST='github.com'
                        github_owner_repo=ijortengab/rcm
                        github_file_path=$(cut -d- -f2 <<< "$command_required")/"$command_required".sh
                        if [ -n "$loud" ];then
                            code rcm install $(sed s,^rcm-,, <<< "$command_required") --url='"'"${PHP_URL_SCHEME}${PHP_URL_HOST}/${github_owner_repo}"'"' --path='"'"$github_file_path"'"'
                        fi
                        OLDINDENT="$INDENT"; INDENT+=''
                        INDENT+='    '
                        Rcm_github_release install "$command_required" "$github_owner_repo" "$github_file_path"
                        INDENT="$OLDINDENT"
                    elif [[ "$command_required" =~ ^rcm- ]];then
                        url=$(grep -F '['$command_required']' <<< "$table_downloads" | tail -1 | sed -E 's/.*\((.*)\).*/\1/')
                        if [ -n "$url" ];then
                            Rcm_parse_url "$url"
                            if [[ "$PHP_URL_HOST" == github.com ]];then
                                # Jika host dari Github, maka terdapat beberapa kemungkinan.
                                # https://github.com/ijortengab/rcm/blob/master/cron/rcm-cron-setup-wsl-port-forwarding.sh
                                # https://github.com/ijortengab/rcm/raw/refs/heads/master/cron/rcm-cron-setup-wsl-autorun-crond.sh
                                # https://github.com/ijortengab/bash/raw/master/commands/ssh-keep-alive-symlink-reference.sh
                                # https://github.com/ijortengab/bash/raw/refs/heads/master/commands/ssh-keep-alive-symlink-reference.sh
                                _github_media_type=$(cut -d/ -f 3 <<< $PHP_URL_PATH)
                                if [[ $_github_media_type == raw ]];then
                                    github_owner_repo=$(cut -d/ -f 1,2 <<< $PHP_URL_PATH)
                                    github_file_path=$(cut -d/ -f 5- <<< $PHP_URL_PATH)
                                    if [ -n "$loud" ];then
                                        code rcm install $(sed s,^rcm-,, <<< "$command_required") --url='"'"${PHP_URL_SCHEME}${PHP_URL_HOST}/${github_owner_repo}"'"' --path='"'"$github_file_path"'"'
                                    fi
                                    OLDINDENT="$INDENT"; INDENT+=''
                                    INDENT+='    '
                                    Rcm_github_release install $command_required $github_owner_repo $github_file_path
                                    INDENT="$OLDINDENT"
                                fi
                            fi
                        fi
                    elif [[ "$command_required" =~ \.sh$ ]];then
                        url=$(grep -F '['$command_required']' <<< "$table_downloads" | tail -1 | sed -E 's/.*\((.*)\).*/\1/')
                        if [ -n "$url" ];then
                            Rcm_parse_url "$url"
                            OLDINDENT="$INDENT"; INDENT+=''
                            save_as="$command_required"
                            if [[ $(basename "$PHP_URL_PATH") == "$command_required" ]];then
                                if [ -n "$loud" ];then
                                    code rcm get "$url"
                                fi
                                INDENT+='    '
                                Rcm_get "$url"
                            else
                                if [ -n "$loud" ];then
                                    code rcm get "$url" --save-as='"'"$command_required"'"'
                                fi
                                INDENT+='    '
                                Rcm_get "$url"
                            fi
                            INDENT="$OLDINDENT"
                        fi
                    fi
                    if ! command -v "$command_required" > /dev/null;then
                        if [ -n "$display_waiting" ];then
                            printf "\r\033[K"
                        fi
                        error Command '`'$command_required'`' not found, unable to auto download.;
                        [ -n "$quiet" ] && kill -SIGTERM $$
                        x
                    fi
                elif [[ ! -x "$BINARY_DIRECTORY/$command_required" ]];then
                    __; magenta chmod a+x "$BINARY_DIRECTORY/$command_required"; _.
                    chmod a+x "$BINARY_DIRECTORY/$command_required"
                fi
            fi
            commands_exists+=("$command_required_raw")
            if [ ! "$command_required_raw" == "$command_required" ];then
                commands_exists+=("$command_required")
            fi
            _help=$("$command_required" --help 2>/dev/null)
            # Hanya mendownload dependency dengan akhiran .sh (shell script) atau prefix rcm.
            _dependency=$(echo "$_help" | sed -n '/^Dependency:/,$p' | sed -n '2,/^\s*$/p' | sed 's/^ *//g' | grep -E '(^rcm|^rcm-[^:]+|[^:]+\.sh)(:[^:]+)*$')
            _download=$(echo "$_help" | sed -n '/^Download:/,$p' | sed -n '2,/^\s*$/p' | sed 's/^ *//g')
            if [ -n "$_download" ];then
                [ -n "$table_downloads" ] && table_downloads+=$'\n'
                table_downloads+="$_download"
            fi
            unset _download
            unset _help
            if [ -n "$_dependency" ];then
                _dependency=($_dependency)
                ArrayDiff _dependency[@] commands_exists[@]
                if [[ ${#_return[@]} -gt 0 ]];then
                    _commands_required_raw+=("${_return[@]}")
                    unset _return
                fi
                unset _dependency
            fi
        done
        if [ -n "$loud" ];then
            ____
        fi
        if [ -n "$debug" ];then
            chapter Dump variable.
        fi
        ArrayUnique _commands_required_raw[@]
        commands_required_raw=("${_return[@]}")
        unset _return
        unset _commands_required_raw
        if [ -n "$debug" ];then
            code 'commands_required_raw=('"${commands_required_raw[@]}"')'
            ____
        fi
    done
    if [ -n "$quiet" ];then
        if [ -n "$display_waiting" ];then
            printf "\r\033[K"
        fi
    fi
}
wordWrapDescription() {
    local paragraph="$1" words_array
    local current_line first_line last
    declare -i min; min=80
    declare -i max; max=100
    declare -i i; i=0
    words_array=($paragraph)
    local count="${#words_array[@]}"
    current_line=
    first_line=1
    for each in "${words_array[@]}"; do
        i+=1
        [ "$i" == "$count" ] && last=1 || last=
        if [ -z "$current_line" ]; then
            if [ -n "$first_line" ];then
                first_line=
                current_line="$each"
                __; _, "$each"
            else
                current_line="$each"
                __; _, "$each"
            fi
            if [ -n "$last" ];then
                _.
            fi
        else
            _current_line="${current_line} ${each}"
            if [ "${#_current_line}" -le $min ];then
                current_line+=" ${each}"
                _, " ${each}"
                if [ -n "$last" ];then
                    _.
                fi
            elif [ "${#_current_line}" -le $max ];then
                _, " ${each}"; _.
                current_line=
            else
                _.; __; _, "$each"
                current_line="$each"
                if [ -n "$last" ];then
                    _.
                fi
            fi
        fi
    done
}
wordWrapCommand() {
    # global words_array
    local inline_description="$1"
    local current_line first_line
    declare -i min; min=80
    declare -i max; max=100
    declare -i i; i=0
    local count="${#words_array[@]}"
    current_line=
    first_line=1
    for each in "${words_array[@]}"; do
        i+=1
        [ "$i" == "$count" ] && last=1 || last=
        if [ -z "$current_line" ]; then
            if [ -z "$first_line" ];then
                current_line="    ${each}"
                e; magenta "    $each";
            else
                first_line=
                if [ -n "$inline_description" ];then
                    e; _, "${inline_description} "; magenta "$each"
                    current_line="${inline_description} ${each}"
                else
                    e; magenta "$each"
                    current_line="$each"
                fi
            fi
            if [ -n "$last" ];then
                _.
            fi
        else
            _current_line="${current_line} ${each}"
            if [ "${#_current_line}" -le $min ];then
                if [ -n "$last" ];then
                    _, ' '; magenta "$each"; _.
                else
                    _, ' '; magenta "$each"
                fi
                current_line+=" ${each}"
            elif [ "${#_current_line}" -le $max ];then
                if [ -n "$last" ];then
                    _, ' '; magenta "${each}"''; _.
                else
                    _, ' '; magenta "${each}"' \'; _.
                fi
                current_line=
            else
                magenta ' \'; _.; e; magenta "    $each"
                current_line="    ${each}"
                if [ -n "$last" ];then
                    _.
                fi
            fi
        fi
    done
}
wordWrapCommandInline() {
    # global words_array
    local inline_description="$1" i
    local current_line first_line
    declare -i min; min=80
    declare -i max; max=100
    declare -i i; i=0
    local count="${#words_array[@]}"
    current_line=
    first_line=1
    for each in "${words_array[@]}"; do
        i+=1
        [ "$i" == "$count" ] && last=1 || last=
        if [ -z "$current_line" ]; then
            if [ -z "$first_line" ];then
                current_line="    ${each}"
                __; magenta "    $each";
            else
                first_line=
                if [ -n "$inline_description" ];then
                    __; _, "${inline_description} "; magenta "$each"
                    current_line="${inline_description} ${each}"
                else
                    __; magenta "$each"
                    current_line="$each"
                fi
            fi
            if [ -n "$last" ];then
                _.
            fi
        else
            _current_line="${current_line} ${each}"
            if [ "${#_current_line}" -le $min ];then
                if [ -n "$last" ];then
                    _, ' '; magenta "$each"; _.
                else
                    _, ' '; magenta "$each"
                fi
                current_line+=" ${each}"
            elif [ "${#_current_line}" -le $max ];then
                if [ -n "$last" ];then
                    _, ' '; magenta "${each}"''; _.
                else
                    _, ' '; magenta "${each}"' \'; _.
                fi
                current_line=
            else
                magenta ' \'; _.; __; magenta "$each"
                current_line="    ${each}"
            fi
        fi
    done
}
wordWrapList() {
    # global words_array
    local inline_description="$1"
    local current_line first_line last
    declare -i min; min=80
    declare -i max; max=100
    declare -i i; i=0
    WRAP_LINE=1
    local count="${#words_array[@]}"
    current_line=
    first_line=1
    for each in "${words_array[@]}"; do
        i+=1
        [ "$i" == "$count" ] && last=1 || last=
        if [ -z "$current_line" ]; then
            if [ -n "$first_line" ];then
                first_line=
                current_line="${inline_description} ${each}"
                __; _, "${inline_description} "; yellow "$each"
            else
                if [ -n "$last" ];then
                    __; _, 'or '; yellow "$each"
                    current_line="or ${each}"
                else
                    __; yellow "$each"
                    current_line="$each"
                fi
            fi
            if [ -n "$last" ];then
                _, '.'; _.
            fi
        else
            if [ -n "$last" ];then
                _current_line="${current_line}, or ${each}"
            else
                _current_line="${current_line}, ${each}"
            fi
            if [ "${#_current_line}" -le $min ];then
                if [ -n "$last" ];then
                    _, ', or '; yellow "$each"; _, '.'; _.
                else
                    _, ', '; yellow "$each"
                fi
                current_line+=", ${each}"
            elif [ "${#_current_line}" -le $max ];then
                if [ -n "$last" ];then
                    _, ', or '; yellow "$each"; _, '.'; _.
                else
                    _, ', '; yellow "$each"; _, ','; _.
                    WRAP_LINE=$((WRAP_LINE+1))
                fi
                current_line=
            else
                WRAP_LINE=$((WRAP_LINE+1))
                if [ -n "$last" ];then
                    _.; __; _, 'or '; yellow "$each"; _, '.'; _.
                    current_line="or ${each}"
                else
                    _.; __; yellow "$each"
                    current_line="$each"
                fi
            fi
        fi
    done
}
Rcm_prompt() {
    local value
    local command="$1"
    local chapter_printed=
    argument_pass=()
    argument_preview=()
    argument_placeholders=
    parameter='<command>'
    available_subcommands=()
    _available_subcommands=`$command --help 2>/dev/null | sed -n -E 's/^Available commands?: ([^\.]+)\.$/\1/p' | head -1`
    if [ -n "$_available_subcommands" ];then
        available_subcommands=(`echo $_available_subcommands | tr ',' ' '`)
    fi
    for value in "${argument_operand_prepopulate[@]}";do
        ArrayShift argument_operand_prepopulate[@]
        break
    done
    if [ -n "$value" ];then
        chapter Prepare argument for command '`'$command_raw'`'.
        chapter_printed=1
        _; _.
        __; green Argument; _, ' '; magenta "$parameter"; _, ' ';  green prepopulated with value' '; yellow "$value"; green .; _.
        argument_operand_prepopulate=("${_return[@]}")
        unset _return
    else
        if [ "${#available_subcommands[@]}" -gt 0 ];then
            chapter Prepare argument for command '`'$command_raw'`'.
            chapter_printed=1
            what=subcommand
            if [ "${#available_subcommands[@]}" -gt 1 ];then
                what=subcommands
            fi
            printSelectDialog available_subcommands[@] "$what"
        fi
    fi
    local subcommand=
    if [ -n "$value" ];then
        argument_pass+=("${value}")
        argument_preview+=("${value}")
        subcommand="$value"
        options=`$command $subcommand --help 2>/dev/null | sed -n '/^Options for command '$subcommand'[:\.]$/,$p' | sed -n '2,/^\s*$/p'`
    else
        options=`$command --help 2>/dev/null | sed -n '/^Options[:\.]$/,$p' | sed -n '2,/^\s*$/p'`
    fi

    if [ -n "$options" ];then
        if [ -z "$chapter_printed" ];then
            chapter Prepare argument for command '`'$command_raw'`'.
        fi
        until [[ -z "$options" ]];do
            parameter=`sed -n 1p <<< "$options" | sed 's/^[[:blank:]]*//;s/[[:blank:]]*$//'`
            is_required=
            is_flag=
            value_addon=
            is_flagvalue=
            save_history=1
            is_typing=
            is_press=
            if [[ "${parameter:(-1):1}" == '*' ]];then
                is_required=1
                parameter="${parameter::-1}"
                parameter=`xargs <<< "$parameter"`
            elif [[ "${parameter:(-1):1}" == '^' ]];then
                is_flag=1
                parameter="${parameter::-1}"
                parameter=`xargs <<< "$parameter"`
            fi
            if [[ "$parameter" == '--' ]];then
                is_required=
                is_flag=
                value_addon=multivalue
            fi
            description=`sed -n 2p <<< "$options" | sed 's/^[[:blank:]]*//;s/[[:blank:]]*$//'`
            if grep -q -i -E '(^|\.\s)Multivalue\.' <<< "$description";then
                value_addon=multivalue
            fi
            if grep -q -i -E '(^|\.\s)Can have value\.' <<< "$description";then
                value_addon=canhavevalue
            fi
            unset count
            declare -i count
            count=3
            placeholders=
            while true; do
                below=`sed -n ${count}p <<< "$options" | sed 's/^[[:blank:]]*//;s/[[:blank:]]*$//'`
                if grep -q '^--' <<< "$below";then
                    break
                fi
                if [ -z "$below" ];then
                    break
                fi
                if [[ "${below:0:1}" == '[' ]];then
                    if [ -n "$placeholders" ];then
                        placeholders+=$'\n'
                    fi
                    placeholders+="$below"
                else
                    description+=$'\n'
                    description+="$below"
                fi

                count+=1
            done
            options=`sed -n ${count}',$p' <<< "$options"`
            value=
            backup_value=
            backup_flag=
            if [ -f "$backup_storage" ];then
                backup_value=$(grep -- "^${parameter}=.*$" "$backup_storage" | tail -1 | sed -E 's|'"^${parameter}=(.*)$"'|\1|')
                backup_flag=$(grep -q -- "^${parameter}$" "$backup_storage" && echo 1)
            fi
            history_value=
            if [ -f "$history_storage" ];then
                history_value=$(grep -- "^${parameter}=.*$" "$history_storage" | tail -9 | sed -E 's|'"^${parameter}=(.*)$"'|\1|')
            fi
            available_values=()
            _available_values=`echo "$description" | grep -i -o -E 'Available values?:[^\.]+\.'| sed -n -E 's/^Available values?: ([^\.]+)\.$/\1/ip'`
            if [ -n "$_available_values" ];then
                description=`echo "$description" | sed -E 's/ *Available values?: ([^\.]+)\.//i'`
            fi
            _available_values_from_command=`echo "$description" | grep -i -o -E 'Values? available from command:\s*[^\(]+\((\)|[^\)]+\))(\.|, or others?\.)'`
            if [ -n "$_available_values_from_command" ];then
                description=`echo "$description" | sed -E 's/ *Values? available from command: ([^\.]+)\.//i'`
            fi
            or_other=
            if [ -n "$_available_values" ];then
                if grep -i -q -E 'or others?' <<< "$_available_values";then
                    or_other=1
                    _available_values=`echo "$_available_values" | sed -E 's/or others?$//'`
                fi
            fi
            if [ -n "$_available_values_from_command" ];then
                if grep -i -q -E 'or others?' <<< "$_available_values_from_command";then
                    or_other=1
                fi
            fi
            if [ -n "$placeholders" ];then
                while read line; do
                    find=$(echo ${line} | cut -d: -f1 | xargs)
                    replace=$(echo ${line} | cut -d: -f2 | xargs)
                    if [ -n "$_available_values" ];then
                        _available_values="${_available_values/"$find"/"$replace"}"
                    fi
                done <<< "$placeholders"
            fi
            if [ -n "$_available_values" ];then
                available_values=(`echo $_available_values | tr ',' ' '`)
            fi
            _; _.
            if [ -n "$_available_values_from_command" ];then
                # Tidak ada history jika value dari command.
                history_value=
                save_history=
            fi
            if [ -n "$_available_values_from_command" ];then
                # parsing argument.
                _command_arguments=$(echo "$_available_values_from_command" | sed -n -E 's/^Values? available from command:\s*([^\)]+\))(\.$|, or others?\.$)/\1/p')
                _command=$(echo "$_command_arguments" | sed -n -E 's/^([^\(]+)\(([^\)]*)\)$/\1/p')
                _arguments=$(echo "$_command_arguments" | sed -n -E 's/^([^\(]+)\(([^\)]*)\)$/\2/p')
                if command -v "$_command" > /dev/null;then
                    if [ -n "$argument_placeholders" ];then
                        while read line; do
                            find=$(echo ${line} | sed -E 's|^([^:]+):.*|\1|' | xargs)
                            replace=$(echo ${line} | sed -E 's|^[^:]+:(.*)|\1|' | xargs)
                            description="${description/"$find"/"$replace"}"
                            if [ -n "$_arguments" ];then
                                _arguments="${_arguments/"$find"/"$replace"}"
                            fi
                        done <<< "$argument_placeholders"
                    fi
                fi
            fi
            if [ -n "$is_flag" ];then
                _ 'Argument '; magenta ${parameter};_, ' is '; _, optional;_, '.'; _.
                _; _.
                while read line; do
                    wordWrapDescription "$line"
                done <<< "$description"
                _boolean=
                for each in "${argument_prepopulate[@]}";do
                    if grep -q -- "^${parameter}-\$" <<< "$each";then
                        _boolean=0
                        break
                    elif grep -q -- "^${parameter}-=" <<< "$each";then
                        # Ada argument lupa dihapus, contoh: --with-roundcube- mail.example.org
                        # maka set sebagai skip.
                        _boolean=0
                        break
                    elif grep -q -- "^${parameter}\$" <<< "$each";then
                        _boolean=1
                        if [[ "$value_addon" == 'canhavevalue' ]];then
                            value_addon=
                        fi
                        break
                    elif grep -q -- "^${parameter}=" <<< "$each";then
                        if [[ "$value_addon" == 'canhavevalue' ]];then
                            _boolean=1
                            value=$(echo "$each" | sed -n -E 's|^[^=]+=(.*)|\1|p')
                            break
                        fi
                    fi
                done
                # Reset first.
                boolean=
                # Variable $boolean digunakan dimana-mana, jadi kita gunakan
                # variable terpisah.
                argument_boolean=
                if [[ "$_boolean" == 0 ]];then
                    _; _.
                    __; _, Argument; _, ' '; _, "$parameter"; _, ' ';  _, set to skip by user,' '; _, pass; _, .; _.
                    backup_flag=
                    argument_boolean=' '
                elif [[ "$_boolean" == 1 ]];then
                    _; _.
                    if [ -n "$value" ];then
                        __; green Argument; _, ' '; magenta "$parameter"; _, ' ';  green prepopulated with value' '; yellow "$value"; green .; _.
                    else
                        __; green Argument; _, ' '; magenta "$parameter"; _, ' ';  green prepopulated.; _.
                    fi
                    backup_flag=
                    argument_boolean=1
                fi
                if [ -n "$backup_flag" ];then
                    printBackupFlagDialog
                    argument_boolean="$boolean"
                fi
                if [ -z "$argument_boolean" ];then
                    _; _.
                    __; _, Add this argument?; _.
                    userInputBooleanDefaultNo
                    argument_boolean="$boolean"
                    is_press=1
                fi
                if [[ "$argument_boolean" == ' ' ]];then
                    argument_boolean=
                fi
                # Populate placeholders.
                if [ -n "$argument_placeholders" ];then
                    argument_placeholders+=$'\n'
                fi
                if [ -n "$argument_boolean" ]; then
                    if [[ "$value_addon" == 'canhavevalue' ]];then
                        if [ -z "$value" ];then
                            _; _.
                            __; _, Do you want fill with value?; _.
                            userInputBooleanDefaultNo
                        fi
                        if [ -n "$value" ];then
                            # fill from prepopulated
                            boolean=1
                        fi
                        if [ -n "$boolean" ]; then
                            if [ -z "$value" ];then
                                if [ -n "$backup_value" ];then
                                    printBackupDialog
                                fi
                            fi
                            if [ -z "$value" ];then
                                if [ -n "$history_value" ];then
                                    printHistoryDialog
                                fi
                            fi
                            if [ -z "$value" ];then
                                if [ "${#available_values[@]}" -gt 0 ];then
                                    printSelectDialog available_values[@]
                                fi
                            fi
                            until [[ -n "$value" ]];do
                                __; read -p "Type the value: " value
                                is_typing=1
                            done
                            # Sanitize user input
                            # Menghapus karakter aneh karena menekan arrow up/down/right/left di keyboard.
                            # Credit: https://stackoverflow.com/a/47918586
                            value=$(echo "$value" | tr -cd '\11\12\15\40-\176' | sed 's/^[[:blank:]]*//;s/[[:blank:]]*$//')
                            argument_pass+=("${parameter}=${value}")
                            argument_preview+=("${parameter}=${value}")
                        else
                            argument_pass+=("${parameter}")
                            argument_preview+=("${parameter}")
                        fi
                    else
                        argument_pass+=("${parameter}")
                        argument_preview+=("${parameter}")
                    fi
                    # Populate placeholders.
                    if [ -n "$value" ];then
                        argument_placeholders+='['"$parameter"']: '"$value"
                    else
                        argument_placeholders+='['"$parameter"']: '"1"
                    fi
                else
                    # Populate placeholders.
                    argument_placeholders+='['"$parameter"']: '"0"
                    argument_preview+=("${parameter}-")
                fi
                if [ -n "$argument_boolean" ];then
                    if [ -n "$is_press" ];then
                        if [ -n "$value" ];then
                            if [ -n "$is_typing" ];then
                                _; _.
                                __; green Argument; _, ' '; magenta "$parameter"; _, ' ';  green added with value' '; yellow $value; green ' 'manually.; _.
                            fi
                        else
                            _; _.
                            __; green Argument; _, ' '; magenta "$parameter"; _, ' ';  green added manually.; _.
                        fi
                    fi
                fi
            elif [[ "$parameter" == '--' ]];then
                _ 'Argument '; magenta ${parameter};_, ' is '; _, optional;_, '.'; _.
                _; _.
                while read line; do
                    wordWrapDescription "$line"
                done <<< "$description"
                __; _, Add value?; _.
                userInputBooleanDefaultNo
                if [ -n "$boolean" ]; then
                    if [ -n "$history_value" ];then
                        printHistoryDialog
                    fi
                    if [ -z "$value" ];then
                        __; read -p "Type the value: " value
                    fi
                    if [ -n "$value" ];then
                        argument_pass+=("${parameter} ${value}")
                        argument_preview+=("${parameter} ${value}")
                    fi
                fi
            else
                if [ -n "$is_required" ];then
                    _ 'Argument '; magenta ${parameter};_, ' is '; yellow required;_, '.'; _.
                else
                    _ 'Argument '; magenta ${parameter};_, ' is '; _, optional;_, '.'; _.
                fi
                _; _.
                while read line; do
                    wordWrapDescription "$line"
                done <<< "$description"
                for each in "${argument_prepopulate[@]}";do
                    if grep -q -- "^${parameter}-\$" <<< "$each";then
                        _; _.
                        __; _, Argument; _, ' '; _, "$parameter"; _, ' ';  _, set to skip by user,' '; _, pass; _, .; _.
                        backup_value=
                        history_value=
                        is_required=
                        value=' '
                        break
                    elif grep -q -- "^${parameter}=" <<< "$each";then
                        value=$(echo "$each" | sed -n -E 's|^[^=]+=(.*)|\1|p')
                        _; _.
                        __; green Argument; _, ' '; magenta "$parameter"; _, ' ';  green prepopulated with value' '; yellow "$value"; green .; _.
                        backup_value=
                        break
                    fi
                done
                if [ -n "$backup_value" ];then
                    printBackupDialog
                fi
                if [ -z "$value" ];then
                    if [ -n "$history_value" ];then
                        printHistoryDialog
                    fi
                fi
                if [ -z "$value" ];then
                    if [ -n "$_available_values_from_command" ];then
                        if command -v "$_command" > /dev/null;then
                            _; _.
                            [ -n "$_arguments" ] && _arguments=' '"$_arguments"
                            words_array=(${_command}${_arguments})
                            wordWrapCommandInline "Value available from command:"
                            mktemp=$(mktemp -p /dev/shm)
                            ${_command}${_arguments} > "$mktemp"
                            exit_code=$?
                            while read line;do
                                [ -n "$line" ] && available_values+=("$line")
                            done < "$mktemp"
                            rm "$mktemp"
                        fi
                    fi
                    if [ "${#available_values[@]}" -gt 0 ];then
                        if [ -n "$or_other" ];then
                            printSelectOtherDialog available_values[@]
                        elif [[ "${#available_values[@]}" -eq 1 && -n "$is_required" ]];then
                            value="${available_values[0]}"
                            _; _.
                            __; _, "Available value: "; yellow "$value";  _, '.'; _.
                            _; _.
                            __; green Argument; _, ' '; magenta "$parameter"; _, ' ';  green filled with the only available value' '; yellow "$value"; green ' 'automatically.; _.
                        else
                            printSelectDialog available_values[@]
                        fi
                    else
                        _; _.
                        if [[ -n "$_available_values_from_command" && ! $exit_code -eq 0 ]];then
                            is_required=
                            __; _, Argument; _, ' '; _, "$parameter"; _, ' ';  _, set to skip by command,' '; _, pass; _, .; _.
                        elif [[ -n "$_available_values_from_command" && -z "$or_other" ]];then
                            is_required=
                            __; _, No value available,' '; _, pass; _, .; _.
                        else
                            if [ -n "$is_required" ];then
                                __; read -p "Type the value: " value
                            else
                                __; read -p "Type the value or leave blank to skip: " value
                            fi
                            is_typing=1
                        fi
                    fi
                fi
                if [ -n "$is_required" ];then
                    until [[ -n "$value" ]];do
                        __; read -p "Type the value: " value
                        is_typing=1
                    done
                fi
                if [[ "$value" == ' ' ]];then
                    value=
                fi
                # Populate placeholders.
                if [ -n "$argument_placeholders" ];then
                    argument_placeholders+=$'\n'
                fi
                if [ -n "$value" ];then
                    # Sanitize user input
                    # Menghapus karakter aneh karena menekan arrow up/down/right/left di keyboard.
                    # Credit: https://stackoverflow.com/a/47918586
                    value=$(echo "$value" | tr -cd '\11\12\15\40-\176' | sed 's/^[[:blank:]]*//;s/[[:blank:]]*$//')
                    argument_pass+=("${parameter}=${value}")
                    argument_preview+=("${parameter}=${value}")
                    argument_placeholders+='['"$parameter"']: '"$value"
                else
                    argument_placeholders+='['"$parameter"']: -'
                    argument_preview+=("${parameter}-")
                fi
                if [[ -n "$value" && "$is_typing" ]];then
                    _; _.
                    __; green Argument; _, ' '; magenta "$parameter"; _, ' ';  green filled with value' '; yellow "$value"; green ' 'manually.; _.
                fi
            fi
            # Backup to text file.
            if [ -n "$value" ];then
                mkdir -p $(dirname "$backup_storage")
                echo "${parameter}=${value}" >> "$backup_storage"
                if [ -f "$history_storage" ];then
                    if grep -q -- "^${parameter}=${value}\$" "$history_storage";then
                        save_history=
                    fi
                fi
                if [ -n "$save_history" ];then
                    mkdir -p $(dirname "$history_storage");
                    echo "${parameter}=${value}" >> "$history_storage"
                fi
            fi
            # Backup to text file for flag.
            if [ -n "$argument_boolean" ];then
                mkdir -p $(dirname "$backup_storage")
                echo "${parameter}" >> "$backup_storage"
            fi
            if [[ "$value_addon" == 'multivalue' ]];then
                again=1
                until [ -z "$again" ]; do
                    if [ -n "$is_flag" ];then
                        _; _.
                        __ Add this argument again?
                        userInputBooleanDefaultNo
                    else
                        _; _.
                        __ Add other value?
                        userInputBooleanDefaultNo
                    fi
                    if [ -n "$boolean" ];then
                        if [ -n "$is_flag" ];then
                            argument_pass+=("${parameter}")
                            argument_preview+=("${parameter}")
                        elif [[ "$parameter" == '--' ]];then
                            if [ -n "$history_value" ];then
                                printHistoryDialog
                            fi
                            if [ -z "$value" ];then
                                __; read -p "Type the value: " value
                            fi
                            if [ -n "$value" ];then
                                argument_pass+=("${value}")
                                argument_preview+=("${value}")
                            fi
                        else
                            __; read -p "Type the value: " value
                            if [ -n "$value" ];then
                                argument_pass+=("${parameter}=${value}")
                                argument_preview+=("${parameter}=${value}")
                            fi
                        fi
                        # Backup to text file.
                        value=$(echo "$value" | sed -E 's/[^/a-z0-9A-Z_.,-]//g' | sed 's/^[[:blank:]]*//;s/[[:blank:]]*$//')
                        if [ -n "$value" ];then
                            mkdir -p $(dirname "$backup_storage");
                            echo "${parameter}=${value}" >> "$backup_storage"
                            if [ -f "$history_storage" ];then
                                if grep -q -- "^${parameter}=${value}\$" "$history_storage";then
                                    save_history=
                                fi
                            fi
                            if [ -n "$save_history" ];then
                                mkdir -p $(dirname "$history_storage");
                                echo "${parameter}=${value}" >> "$history_storage"
                            fi
                        fi
                    else
                        again=
                    fi
                done
            fi
        done
        ____
    fi
}
Rcm_prompt_sigint() {
    local shortoptions
    [ -z "$resolve_dependencies" ] && shortoptions+='x'
    [ -n "$slow" ] && shortoptions+='s'
    if [ -n "$verbose" ];then
        for ((i = 0 ; i < "$verbose" ; i++)); do
            shortoptions+='v'
        done
    fi
    [ -n "$shortoptions" ] && shortoptions=" -${shortoptions}"
    _.;
    _.;
    error Interrupt by User.; _.
    _ Use command below to return to the last dialog.; _.
    if [ -z "$RCM_LAST_COMMAND" ];then
        RCM_LAST_COMMAND="rcm${shortoptions}${isnoninteractive} ${command_raw} --"
    fi
    for each in "${argument_preview[@]}"; do RCM_LAST_COMMAND+=" ${each}"; done
    words_array=($RCM_LAST_COMMAND)
    wordWrapCommand
    exit 0
}

# Requirement, validate, and populate value.
rcm_version=`printVersion`
immediately=
[ -z "$resolve_dependencies" ] && resolve_dependencies=1
[ "$resolve_dependencies" == 0 ] && resolve_dependencies=
[ -z "$interactive" ] && interactive=1
[ "$interactive" == 0 ] && interactive=
if [ -n "$louder" ];then
    chapter Dump variable.
    code 'BINARY_DIRECTORY="'$BINARY_DIRECTORY'"'
    code 'RCM_INTERACTIVE="'$RCM_INTERACTIVE'"'
    code 'RCM_VERBOSE="'$RCM_VERBOSE'"'
    code 'RCM_RESOLVE_DEPENDENCIES="'$RCM_RESOLVE_DEPENDENCIES'"'
    code 'RCM_TABLE_DOWNLOADS="'"$RCM_TABLE_DOWNLOADS"'"'
    code 'RCM_FAST="'$RCM_FAST'"'
    code 'interactive="'$interactive'"'
    code 'verbose="'$verbose'"'
    code 'quiet="'$quiet'"'
    code 'loud="'$loud'"'
    code 'louder="'$louder'"'
    code 'debug="'$debug'"'
    code 'resolve_dependencies="'$resolve_dependencies'"'
    ____
fi

[ "$EUID" -ne 0 ] && { error This script needs to be run with superuser privileges.; x; }

if [ ! -d "$BINARY_DIRECTORY" ];then
    mkdir -p "$BINARY_DIRECTORY"
    if [ ! -d "$BINARY_DIRECTORY" ];then
        error Direktori '`'$BINARY_DIRECTORY'`' tidak ditemukan.; x
    fi
fi

PATH="${BINARY_DIRECTORY}:${PATH}"

_help=$("$command" --help 2>/dev/null)
if [ -n "$resolve_dependencies" ];then
    # Simpan informasi download.
    _download=$(echo "$_help" | sed -n '/^Download:/,$p' | sed -n '2,/^\s*$/p' | sed 's/^ *//g')
    if [ -n "$_download" ];then
        [ -n "$table_downloads" ] && table_downloads+=$'\n'
        table_downloads+="$_download"
    fi
    if [ -n "$quiet" ];then
        chapter Resolve dependencies.
        trap x SIGTERM
        Rcm_resolve_dependencies "${command}${command_version}" &
        pid=$!
        spin='-\|/'
        i=0
        while kill -0 $pid 2>/dev/null
        do
          i=$(( (i+1) %4 ))
          printf "\r" >&2; __; _, "Waiting...${spin:$i:1}"
          sleep .1
        done
        # e '"$display_waiting"' "$display_waiting"
        __ Resolved.
        ____
    else
        Rcm_resolve_dependencies "${command}${command_version}"
    fi
fi
rcm_depends=$(echo "$_help" | sed -n '/^Dependency:/,$p' | sed -n '2,/^\s*$/p' | sed 's/^ *//g' | grep -E '^rcm(:[^:]+)*$')
# Jika rcm dijadikan sebagai dependency, maka command tersebut adalah
# wrapper yang akan kembali mengeksekusi rcm sehingga muncul prompt lagi.
if [ -n "$rcm_depends" ];then
    immediately=1
fi
_new_arguments=()
argument_prepopulate=()
argument_operand_prepopulate=()
argument_after_doubledash=()

if [ $# -gt 0 ];then
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --)
                immediately=1
                while [[ $# -gt 0 ]]; do
                    case "$1" in
                        *) _new_arguments+=("$1"); argument_after_doubledash+=("$1"); shift ;;
                    esac
                done
                ;;
            --[^-]*)
                if [[ "$2" =~ ^-- ]];then
                    argument_prepopulate+=("$1");
                elif [[ ! $2 == "" && ! $2 =~ ^-[^-] ]];then
                    argument_prepopulate+=("$1"="$2");
                    shift
                else
                    argument_prepopulate+=("$1");
                fi
                shift
                ;;
            -[^-]*)
                # Short option tidak bisa dijadikan prepopulate.
                shift
                ;;
            *)
                argument_operand_prepopulate+=("$1");
                shift
        esac
    done
fi
backup_storage=$HOME'/.cache/rcm/rcm.'$command'.bak'
history_storage=$HOME'/.cache/rcm/rcm.'$command'.history'
trap Rcm_prompt_sigint SIGINT
Rcm_prompt $command
trap x SIGINT
if [[ "${#argument_pass[@]}" -gt 0 ]];then
    set -- "${argument_pass[@]}" "${_new_arguments[@]}"
    unset argument_pass _new_arguments
else
    set -- "${_new_arguments[@]}"
    unset _new_arguments
fi
[ -f "$backup_storage" ] && rm "$backup_storage"

command -v "$command" >/dev/null || { red "Unable to proceed, $command command not found."; x; }

shortoptions=
[ -z "$resolve_dependencies" ] && shortoptions+='x'
[ -n "$slow" ] && shortoptions+='s'
[ -n "$slow" ] && isfast='' || isfast=' --fast'
[ -n "$verbose" ] && {
    for ((i = 0 ; i < "$verbose" ; i++)); do
        isverbose+=' --verbose'
        shortoptions+='v'
    done
} || isverbose=
[ -n "$shortoptions" ] && shortoptions=" -${shortoptions}"
argument_preview+=(--)

# Boolean export as 0 or 1.
[ -n "$interactive" ] && RCM_INTERACTIVE=1 || RCM_INTERACTIVE=0
export RCM_INTERACTIVE="$RCM_INTERACTIVE"
[ -n "$resolve_dependencies" ] && RCM_RESOLVE_DEPENDENCIES=1 || RCM_RESOLVE_DEPENDENCIES=0
export RCM_RESOLVE_DEPENDENCIES="$RCM_RESOLVE_DEPENDENCIES"
# Other variable, export as is.
RCM_VERBOSE="$verbose"
export RCM_VERBOSE="$RCM_VERBOSE"
RCM_FAST="$fast"
export RCM_FAST="$RCM_FAST"
# Fill last command if empty.
if [ -z "$RCM_LAST_COMMAND" ];then
    RCM_LAST_COMMAND="rcm${shortoptions}${isnoninteractive} ${command_raw} --"
fi
for each in "${argument_preview[@]}"; do RCM_LAST_COMMAND+=" ${each}"; done
export RCM_LAST_COMMAND="$RCM_LAST_COMMAND"
# Fill always.
export RCM_TABLE_DOWNLOADS="$table_downloads"

chapter Command has been built.
_ Use command below to arrive in this position with non-interactive mode.; _.
if [ "${#preview[@]}" -gt 0 ];then
    words_array=($RCM_LAST_COMMAND)
else
    _rcm_last_command="$RCM_LAST_COMMAND"
    ArrayShift argument_after_doubledash[@]
    argument_after_doubledash=("${_return[@]}")
    unset _return
    for each in "${argument_after_doubledash[@]}"; do _rcm_last_command+=" ${each}"; done
    words_array=($_rcm_last_command)
fi
wordWrapCommand
____

chapter The real command has been built.
# Hanya --fast dan --verbose yang juga dioper ke command sebagai option.
# Option yang tidak dikirim adalah --interactive, dan --with(out)-resolve-dependencies
words_array=(${command} ${isfast} ${isverbose} "$@")
wordWrapCommand
____

if [ -n "$immediately" ];then
    chapter The real command is execute.
    _ Direct to '`'${command}'`' command.; _.
    ____

elif [ -z "$interactive" ];then
    chapter The real command is being executed.
    _ Direct to '`'${command}'`' command.; _.
    ____

    sleepExtended 3 30
else
    chapter Execute:
    _; _.
    userInputBooleanDefaultYes
    if [ -z "$boolean" ];then
        exit 0
    fi
    ____
fi

chapter Timer Start.
_ Begin: $(date +%Y%m%d-%H%M%S); _.
Rcm_BEGIN=$SECONDS
____

INDENT+="    " BINARY_DIRECTORY="$BINARY_DIRECTORY" $command $isfast $isnoninteractive $isverbose "$@"

chapter Timer Finish.
_ End: $(date +%Y%m%d-%H%M%S); _.
Rcm_END=$SECONDS
duration=$(( Rcm_END - Rcm_BEGIN ))
hours=$((duration / 3600)); minutes=$(( (duration % 3600) / 60 )); seconds=$(( (duration % 3600) % 60 ));
runtime=`printf "%02d:%02d:%02d" $hours $minutes $seconds`
_ Duration: $runtime; if [ $duration -gt 60 ];then _, " (${duration} seconds)"; fi; _, '.'; _.
____

exit 0

# parse-options.sh \
# --compact \
# --clean \
# --no-hash-bang \
# --no-original-arguments \
# --no-error-invalid-options \
# --with-end-options-specific-operand \
# --with-end-options-double-dash \
# --no-error-require-arguments << EOF | clip
# INCREMENT=(
    # '--verbose|-v'
# )
# FLAG=(
# '--slow|-s'
# '--version|-V'
# '--help|-h'
# )
# VALUE=(
# )
# MULTIVALUE=(
# )
# FLAG_VALUE=(
# )
# CSV=(
    # 'long:--interactive,parameter:interactive'
    # 'long:--non-interactive,short:-x,parameter:interactive,flag_option:reverse'
    # 'long:--with-resolve-dependencies,parameter:resolve_dependencies'
    # 'long:--without-resolve-dependencies,parameter:resolve_dependencies,flag_option:reverse'
    # 'long:--resolved,short:-r,parameter:resolve_dependencies,flag_option:reverse'
# )
# OPERAND=(
# install
# update
# get
# history
# list
# )
# EOF
# clear

# parse-options.sh \
# --compact \
# --clean \
# --no-hash-bang \
# --without-end-options-double-dash \
# --no-original-arguments \
# --no-error-invalid-options \
# --no-error-require-arguments << EOF | clip
# FLAG=(
# --rollback
# )
# VALUE=(
# --url
# --path
# )
# EOF
# clear

# parse-options.sh \
# --compact \
# --clean \
# --no-hash-bang \
# --no-original-arguments \
# --no-error-invalid-options \
# --no-error-require-arguments << EOF | clip
# FLAG=(
# --delete-all
# --fast
# )
# MULTIVALUE=(
# --delete
# )
# EOF
# clear

# parse-options.sh \
# --compact \
# --clean \
# --no-hash-bang \
# --no-original-arguments \
# --no-error-invalid-options \
# --without-end-options-double-dash \
# --no-error-require-arguments << EOF | clip
# FLAG=(
# )
# VALUE=(
# --url
# --path
# --source
# )
# MULTIVALUE=(
# )
# FLAG_VALUE=(
# )
# CSV=(
# )
# EOF
# clear

# parse-options.sh \
# --compact \
# --clean \
# --no-hash-bang \
# --no-original-arguments \
# --no-error-invalid-options \
# --without-end-options-double-dash \
# --no-error-require-arguments << EOF | clip
# FLAG=(
# )
# VALUE=(
# --save-as
# )
# MULTIVALUE=(
# )
# FLAG_VALUE=(
# )
# CSV=(
# )
# EOF
# clear

# parse-options.sh \
# --compact \
# --clean \
# --no-hash-bang \
# --no-original-arguments \
# --no-error-invalid-options \
# --without-end-options-double-dash \
# --no-error-require-arguments << EOF | clip
# FLAG=(
# --raw
# )
# EOF
# clear
